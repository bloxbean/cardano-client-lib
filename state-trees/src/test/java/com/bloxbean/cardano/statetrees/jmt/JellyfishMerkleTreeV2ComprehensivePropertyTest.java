package com.bloxbean.cardano.statetrees.jmt;

import com.bloxbean.cardano.client.util.HexUtil;
import com.bloxbean.cardano.statetrees.api.HashFunction;
import com.bloxbean.cardano.statetrees.common.hash.Blake2b256;
import com.bloxbean.cardano.statetrees.jmt.commitment.ClassicJmtCommitmentScheme;
import com.bloxbean.cardano.statetrees.jmt.commitment.CommitmentScheme;
import com.bloxbean.cardano.statetrees.jmt.store.InMemoryJmtStore;
import com.bloxbean.cardano.statetrees.jmt.store.JmtStore;
import org.junit.jupiter.api.Test;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive property-based tests for JellyfishMerkleTreeV2.
 * These tests validate correctness against the reference implementation
 * for operations that are fully supported in V2.
 *
 * <p>Note: Delete operations are not yet implemented in V2, so these tests
 * focus on inserts and updates only.</p>
 */
class JellyfishMerkleTreeV2ComprehensivePropertyTest {

    private static final HashFunction HASH = Blake2b256::digest;
    private static final CommitmentScheme COMMITMENTS = new ClassicJmtCommitmentScheme(HASH);

    /**
     * Property: V2 root hashes match reference implementation for random insert/update sequences
     */
    @Test
    void property_random_inserts_and_updates_match_reference() {
        long seed = 0xDEADBEEFCAFEBABEL;
        Random random = new Random(seed);

        JellyfishMerkleTree reference = new JellyfishMerkleTree(COMMITMENTS, HASH);

        try (JmtStore store = new InMemoryJmtStore()) {
            JellyfishMerkleTreeV2 v2 = new JellyfishMerkleTreeV2(store, COMMITMENTS, HASH);

            Map<byte[], byte[]> state = new LinkedHashMap<>();

            // Run 200 versions of random mutations
            for (int version = 0; version < 200; version++) {
                // Generate 1-10 random mutations per version
                int numMutations = 1 + random.nextInt(10);
                Map<byte[], byte[]> updates = new LinkedHashMap<>();

                for (int i = 0; i < numMutations; i++) {
                    byte[] key;

                    // 50% chance to update existing key, 50% chance to insert new key
                    if (!state.isEmpty() && random.nextBoolean()) {
                        // Update existing key
                        List<byte[]> existingKeys = new ArrayList<>(state.keySet());
                        key = existingKeys.get(random.nextInt(existingKeys.size()));
                    } else {
                        // Insert new key
                        key = randomKey(random);
                    }

                    byte[] value = randomValue(random);
                    updates.put(key, value);
                    state.put(key, value);
                }

                // Commit to both implementations
                JellyfishMerkleTree.CommitResult refResult = reference.commit(version, updates);
                JellyfishMerkleTreeV2.CommitResult v2Result = v2.put(version, updates);

                // Verify root hashes match
                assertArrayEquals(refResult.rootHash(), v2Result.rootHash(),
                        String.format("Root mismatch at version %d with %d mutations", version, numMutations));

                // Verify stored root hash
                assertArrayEquals(refResult.rootHash(), store.rootHash(version).orElseThrow(),
                        String.format("Stored root mismatch at version %d", version));
            }
        } catch (Exception e) {
            fail("Unexpected exception during property test", e);
        }
    }

    /**
     * Property: Proofs generated by V2 match reference implementation structure
     */
    @Test
    void property_proof_structure_matches_reference() {
        long seed = 0x123456789ABCDEF0L;
        Random random = new Random(seed);

        JellyfishMerkleTree reference = new JellyfishMerkleTree(COMMITMENTS, HASH);

        try (JmtStore store = new InMemoryJmtStore()) {
            JellyfishMerkleTreeV2 v2 = new JellyfishMerkleTreeV2(store, COMMITMENTS, HASH);

            Map<byte[], byte[]> allKeys = new LinkedHashMap<>();

            // Build up tree over 50 versions
            for (int version = 0; version < 50; version++) {
                Map<byte[], byte[]> updates = new LinkedHashMap<>();

                // Add 3-5 keys per version
                int numKeys = 3 + random.nextInt(3);
                for (int i = 0; i < numKeys; i++) {
                    byte[] key = randomKey(random);
                    byte[] value = randomValue(random);
                    updates.put(key, value);
                    allKeys.put(key, value);
                }

                reference.commit(version, updates);
                v2.put(version, updates);

                // Sample some keys for proof validation
                List<byte[]> keysToCheck = new ArrayList<>(allKeys.keySet());
                if (keysToCheck.size() > 5) {
                    Collections.shuffle(keysToCheck, random);
                    keysToCheck = keysToCheck.subList(0, 5);
                }

                for (byte[] key : keysToCheck) {
                    Optional<JmtProof> refProof = reference.getProof(key, version);
                    Optional<JmtProof> v2Proof = v2.getProof(key, version);

                    assertEquals(refProof.isPresent(), v2Proof.isPresent(),
                            String.format("Proof presence mismatch for key %s at version %d",
                                    HexUtil.encodeHexString(key), version));

                    if (refProof.isPresent()) {
                        JmtProof refP = refProof.get();
                        JmtProof v2P = v2Proof.get();

                        assertEquals(refP.type(), v2P.type(),
                                String.format("Proof type mismatch for key %s at version %d",
                                        HexUtil.encodeHexString(key), version));

                        if (refP.valueHash() != null && v2P.valueHash() != null) {
                            assertArrayEquals(refP.valueHash(), v2P.valueHash(),
                                    String.format("Value hash mismatch for key %s at version %d",
                                            HexUtil.encodeHexString(key), version));
                        }

                        assertEquals(refP.steps().size(), v2P.steps().size(),
                                String.format("Proof step count mismatch for key %s at version %d",
                                        HexUtil.encodeHexString(key), version));
                    }
                }
            }
        } catch (Exception e) {
            fail("Unexpected exception during proof property test", e);
        }
    }

    /**
     * Property: Concurrent key updates produce deterministic results
     */
    @Test
    void property_batch_updates_are_deterministic() {
        long seed = 0xFEEDFACEDEADBEEFL;
        Random random = new Random(seed);

        try (JmtStore store1 = new InMemoryJmtStore();
             JmtStore store2 = new InMemoryJmtStore()) {

            JellyfishMerkleTreeV2 tree1 = new JellyfishMerkleTreeV2(store1, COMMITMENTS, HASH);
            JellyfishMerkleTreeV2 tree2 = new JellyfishMerkleTreeV2(store2, COMMITMENTS, HASH);

            // Generate 100 random batches
            for (int version = 0; version < 100; version++) {
                Map<byte[], byte[]> updates = new LinkedHashMap<>();

                int numUpdates = 10 + random.nextInt(20);
                for (int i = 0; i < numUpdates; i++) {
                    updates.put(randomKey(random), randomValue(random));
                }

                // Apply same batch to both trees
                JellyfishMerkleTreeV2.CommitResult result1 = tree1.put(version, updates);
                JellyfishMerkleTreeV2.CommitResult result2 = tree2.put(version, updates);

                // Results must be identical
                assertArrayEquals(result1.rootHash(), result2.rootHash(),
                        String.format("Non-deterministic behavior at version %d", version));

                assertEquals(result1.nodes().size(), result2.nodes().size(),
                        String.format("Different node counts at version %d", version));
            }
        } catch (Exception e) {
            fail("Unexpected exception during determinism test", e);
        }
    }

    /**
     * Property: Large batches produce correct results
     */
    @Test
    void property_large_batch_correctness() {
        long seed = 0xCAFEBABE12345678L;
        Random random = new Random(seed);

        JellyfishMerkleTree reference = new JellyfishMerkleTree(COMMITMENTS, HASH);

        try (JmtStore store = new InMemoryJmtStore()) {
            JellyfishMerkleTreeV2 v2 = new JellyfishMerkleTreeV2(store, COMMITMENTS, HASH);

            // Test batches of increasing size: 100, 500, 1000 keys
            int[] batchSizes = {100, 500, 1000};

            for (int i = 0; i < batchSizes.length; i++) {
                int batchSize = batchSizes[i];
                Map<byte[], byte[]> updates = new LinkedHashMap<>();

                for (int j = 0; j < batchSize; j++) {
                    updates.put(randomKey(random), randomValue(random));
                }

                JellyfishMerkleTree.CommitResult refResult = reference.commit(i, updates);
                JellyfishMerkleTreeV2.CommitResult v2Result = v2.put(i, updates);

                assertArrayEquals(refResult.rootHash(), v2Result.rootHash(),
                        String.format("Root mismatch for batch size %d", batchSize));
            }
        } catch (Exception e) {
            fail("Unexpected exception during large batch test", e);
        }
    }

    /**
     * Property: Sequential single-key updates produce correct intermediate states
     */
    @Test
    void property_sequential_updates_correctness() {
        long seed = 0xABCDEF0123456789L;
        Random random = new Random(seed);

        JellyfishMerkleTree reference = new JellyfishMerkleTree(COMMITMENTS, HASH);

        try (JmtStore store = new InMemoryJmtStore()) {
            JellyfishMerkleTreeV2 v2 = new JellyfishMerkleTreeV2(store, COMMITMENTS, HASH);

            // Insert 200 unique keys one at a time
            for (int version = 0; version < 200; version++) {
                Map<byte[], byte[]> updates = new LinkedHashMap<>();
                updates.put(randomKey(random), randomValue(random));

                JellyfishMerkleTree.CommitResult refResult = reference.commit(version, updates);
                JellyfishMerkleTreeV2.CommitResult v2Result = v2.put(version, updates);

                assertArrayEquals(refResult.rootHash(), v2Result.rootHash(),
                        String.format("Root mismatch at sequential version %d", version));
            }
        } catch (Exception e) {
            fail("Unexpected exception during sequential test", e);
        }
    }

    /**
     * Property: Updating same keys multiple times produces correct results
     */
    @Test
    void property_key_update_correctness() {
        long seed = 0x9876543210FEDCBAL;
        Random random = new Random(seed);

        JellyfishMerkleTree reference = new JellyfishMerkleTree(COMMITMENTS, HASH);

        try (JmtStore store = new InMemoryJmtStore()) {
            JellyfishMerkleTreeV2 v2 = new JellyfishMerkleTreeV2(store, COMMITMENTS, HASH);

            // Create 10 fixed keys
            List<byte[]> fixedKeys = new ArrayList<>();
            for (int i = 0; i < 10; i++) {
                fixedKeys.add(randomKey(random));
            }

            // Update them randomly over 100 versions
            for (int version = 0; version < 100; version++) {
                Map<byte[], byte[]> updates = new LinkedHashMap<>();

                // Update 3-5 random keys from the fixed set
                int numUpdates = 3 + random.nextInt(3);
                for (int i = 0; i < numUpdates; i++) {
                    byte[] key = fixedKeys.get(random.nextInt(fixedKeys.size()));
                    byte[] value = randomValue(random);
                    updates.put(key, value);
                }

                JellyfishMerkleTree.CommitResult refResult = reference.commit(version, updates);
                JellyfishMerkleTreeV2.CommitResult v2Result = v2.put(version, updates);

                assertArrayEquals(refResult.rootHash(), v2Result.rootHash(),
                        String.format("Root mismatch for key update at version %d", version));
            }
        } catch (Exception e) {
            fail("Unexpected exception during key update test", e);
        }
    }

    // ===== Helper Methods =====

    private byte[] randomKey(Random random) {
        byte[] key = new byte[20 + random.nextInt(20)];
        random.nextBytes(key);
        return key;
    }

    private byte[] randomValue(Random random) {
        byte[] value = new byte[32 + random.nextInt(32)];
        random.nextBytes(value);
        return value;
    }
}
