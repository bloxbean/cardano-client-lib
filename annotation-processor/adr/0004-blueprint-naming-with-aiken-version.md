# ADR 0004: Blueprint Test File Naming with Aiken Version

- Status: Accepted
- Date: 2026-02-04
- Owners: Cardano Client Lib maintainers

## Context

The annotation processor must handle blueprint files generated by different versions of the Aiken compiler. As Aiken evolves, its blueprint output format changes in subtle ways that can affect code generation:

1. **Structural differences**: Modern Aiken (v1.1.x+) introduces generic types (`Option<T>`, `List<X>`), namespaced abstract types, and refined JSON Pointer escaping that older versions (v1.0.x-alpha) did not use.

2. **CIP-57 compliance variations**: Different Aiken versions interpret the CIP-57 specification differently, particularly around opaque PlutusData types and schema references.

3. **Debugging challenges**: When tests fail, it's unclear whether the issue is version-specific without manually inspecting the blueprint's `preamble.compiler.version`.

4. **Regression prevention**: We need to maintain compatibility with older Aiken versions while supporting new ones, but our test suite lacks clear version markers.

5. **Test organization**: Functional tests (like CIP113Token) test end-to-end behavior with large real-world blueprints, while unit tests (like AnyPlutusDataBlueprint) target specific CIP-57 features. The distinction is not evident from filenames.

### Example of Version-Specific Bug

Commit `5dd5d2d5` ("Support opaque PlutusData types") fixed a bug where **namespaced abstract redeemer types** (e.g., `cardano/transaction/Redeemer`) incorrectly attempted class generation instead of mapping to `PlutusData.class`.

- **AnyPlutusDataBlueprint** (Aiken v1.0.21-alpha) had simple global-namespace abstract types (`Data`) that already worked.
- **CIP113Token** (Aiken v1.1.17) exposed the bug with complex namespaced validators like `cardano~1transaction~1Redeemer`.

Without version information in filenames, this distinction was invisible.

## Decision

Adopt a standardized naming convention for blueprint test files that includes the **sanitized Aiken compiler version**:

```
<BlueprintName>_aiken_v<major>_<minor>_<patch>_<prerelease>.json
```

### Sanitization Rules

Convert the Aiken version from `preamble.compiler.version` using these rules:

| Character | Replacement | Example |
|-----------|-------------|---------|
| Dots (`.`) | Underscore (`_`) | `v1.0.21` → `v1_0_21` |
| Plus (`+`) | Underscore (`_`) | `+4b04517` → `_4b04517` (omit in practice) |
| Dash in prerelease (`-alpha`, `-rc1`) | Underscore (`_`) | `-alpha` → `_alpha` |
| Build metadata (`+hash`) | **Omit entirely** | `v1.0.21-alpha+4b04517` → `v1_0_21_alpha` |

### Examples

| Aiken Compiler Version | Filename |
|------------------------|----------|
| `v1.0.21-alpha+4b04517` | `AnyPlutusDataBlueprint_aiken_v1_0_21_alpha.json` |
| `v1.1.17+c3a7fba` | `CIP113Token_aiken_v1_1_17.json` |
| `v2.0.0` | `HelloWorld_aiken_v2_0_0.json` |

### Migration Strategy

When adding or updating blueprint test files:

1. Extract `preamble.compiler.version` from the blueprint JSON.
2. Sanitize the version per the rules above.
3. Rename the file: `<Name>_aiken_v<sanitized>.json`.
4. Update the corresponding Java interface `@Blueprint(fileInResources = "blueprint/<new_name>.json")`.
5. Document version-specific behaviors in comments or test descriptions.

## Goals

- **Version transparency**: Make Aiken version immediately visible in test directory listings.
- **Regression tracking**: Clearly identify which tests cover which Aiken eras (alpha, stable, modern).
- **Debugging efficiency**: When tests fail, developers instantly know if it's a version-specific issue.
- **Test organization**: Distinguish functional tests (real-world contracts) from unit tests (feature-focused).
- **Historical context**: Preserve knowledge of which blueprint structures correspond to which compiler versions.

## Non-Goals

- **Runtime version detection**: This convention applies only to test resources, not production blueprint loading.
- **Automatic filename generation**: No tooling is provided to rename files automatically; this is a manual convention.
- **Backward compatibility enforcement**: Older test files without version suffixes remain valid; new files should follow the convention.
- **Version validation**: The annotation processor does not validate that the filename matches `preamble.compiler.version`.

## Implementation

### Updated Test Files

#### AnyPlutusDataBlueprint (Aiken v1.0.21-alpha)

**Purpose**: Unit test demonstrating CIP-57 opaque PlutusData handling with namespaced types.

**Before** (simple global abstract type):
```json
{
  "redeemer": { "$ref": "#/definitions/Data" },
  "definitions": {
    "Data": {
      "title": "anyPlutusData",
      "description": "Any Plutus data."
    }
  }
}
```

**After** (namespaced abstract types to expose the bug):
```json
{
  "redeemer": {
    "$ref": "#/definitions/validator~1AbstractRedeemer"
  },
  "definitions": {
    "validator/AbstractRedeemer": {
      "title": "AbstractRedeemer",
      "description": "Namespaced abstract redeemer (opaque PlutusData per CIP-57)"
    },
    "test_module/CustomData": {
      "title": "CustomData",
      "description": "Namespaced abstract data type for field reference test"
    },
    "test_module/Foo": {
      "fields": [
        { "$ref": "#/definitions/Int" },
        { "$ref": "#/definitions/test_module~1CustomData" }
      ]
    }
  }
}
```

**What This Tests**:
1. Direct validator redeemer reference to namespaced abstract type (`validator/AbstractRedeemer`).
2. **Field reference to namespaced abstract type** — the bug scenario fixed in commit `5dd5d2d5`.
3. JSON Pointer escaping (`~1` for `/`) per RFC 6901.

**Expected Behavior** (with fix):
- `AbstractRedeemer` and `CustomData` map to `PlutusData.class`.
- No Java class generation for these opaque types.
- `Foo` constructor field `customData` has type `PlutusData`.

**Behavior Without Fix** (bug):
- Attempts to generate `com.bloxbean...validator.AbstractRedeemer.java`.
- Attempts to generate `com.bloxbean...test_module.CustomData.java`.
- Compilation fails because opaque types cannot be instantiated.

**Filename**: `AnyPlutusDataBlueprint_aiken_v1_0_21_alpha.json`

#### CIP113Token (Aiken v1.1.17)

**Purpose**: Functional test using a real-world CIP-113 token contract with 20+ validators.

**Key Features**:
- Complex hierarchical validator structure (`config.config_mint_validator.mint`, `config.config_spend_validator.spend`).
- Extensive use of `cardano/transaction/Redeemer` (namespaced abstract type).
- Tests validator name collision handling (multiple validators named "mint", "else", "spend").

**Role**: End-to-end validation that the processor handles large modern blueprints correctly. Not designed to test specific CIP-57 edge cases.

**Filename**: `CIP113Token_aiken_v1_1_17.json` (if we were to rename it).

### Test Organization Guidelines

| Test Type | Purpose | Location | Naming |
|-----------|---------|----------|--------|
| **Unit Tests** | Test specific CIP-57 features or edge cases | `src/test/resources/blueprint/` | `<Feature>_aiken_v<version>.json` |
| **Functional Tests** | Test real-world contracts end-to-end | `src/it/resources/blueprint/` | `<ContractName>_aiken_v<version>.json` |

**Examples**:
- Unit: `AnyPlutusDataBlueprint_aiken_v1_0_21_alpha.json` — Tests opaque PlutusData.
- Functional: `SundaeSwapV3_aiken_v1_1_17.json` — Tests a complete DEX contract.

## Alternatives Considered

### 1. No Version in Filename
**Pros**: Simpler filenames, less noise.
**Cons**: Version information hidden in JSON, harder to identify version-specific issues at a glance.
**Verdict**: Rejected — debugging efficiency is worth the longer filenames.

### 2. Version Directory Structure
**Example**: `blueprints/v1_0_21_alpha/AnyPlutusData.json`
**Pros**: Clean separation by version.
**Cons**: Requires reorganizing test resources, more complex `@Blueprint` paths, harder to compare versions side-by-side.
**Verdict**: Rejected — flat structure with versioned names is simpler.

### 3. Include Full Build Metadata (`+hash`)
**Example**: `AnyPlutusDataBlueprint_aiken_v1_0_21_alpha_4b04517.json`
**Pros**: Complete version traceability.
**Cons**: Excessively long filenames, build metadata rarely relevant for testing.
**Verdict**: Rejected — omit build metadata, keep only semantic version.

### 4. Version in Test Method Name Only
**Example**: `@Test void anyPlutusData_aiken_v1_0_21_alpha() { ... }`
**Pros**: Blueprint filename unchanged.
**Cons**: Doesn't help when browsing test resources, test method names become cluttered.
**Verdict**: Rejected — version should be visible at the resource level.

## Consequences

### Positive
- **Immediate version visibility**: Developers know which Aiken version each test targets without opening files.
- **Better regression testing**: Easy to identify if a bug affects specific Aiken versions.
- **Clear test intent**: Unit tests (small, focused) vs. functional tests (large, real-world) are distinguishable.
- **Historical documentation**: Test suite becomes a living record of Aiken's blueprint evolution.

### Neutral
- **Longer filenames**: Acceptable tradeoff for clarity.
- **Manual renaming required**: Existing tests must be updated by hand (one-time cost).

### Negative
- **Potential confusion**: Developers might misinterpret the version as a requirement (mitigated by documentation).
- **Maintenance overhead**: When updating to new Aiken versions, old test files should remain for regression.

## Related Commits

- **5dd5d2d5**: feat: Support opaque PlutusData types and fix validator name collisions
  - Fixed `FieldSpecProcessor` to detect opaque types in `refSchema` (the namespaced abstract type bug).
  - Added `BlueprintUtil.isAbstractPlutusDataType()` per CIP-57 spec.

- **636b3bd1**: refactor: Centralize JSON Pointer unescaping and fix SundaeSwap V3 issues
  - Fixed modern Aiken (v1.1.x+) blueprint handling with generic types.
  - Centralized JSON Pointer unescaping (RFC 6901).

## CIP-57 Opaque PlutusData Reminder

Per CIP-57 specification:
> "The dataType keyword is optional. When missing, the instance is implicitly typed as an opaque Plutus Data."

A schema is opaque PlutusData when:
- `dataType` is missing or null.
- No structural properties (`anyOf`, `fields`, `items`, `keys`, `values`, `left`, `right`).

These map to `com.bloxbean.cardano.client.plutus.spec.PlutusData`, **not** generated Java classes.

## Implementation Notes

- **Sanitization is mandatory**: Filesystem-illegal characters (`+`, `/`) must be replaced.
- **Omit build metadata**: The `+hash` portion of versions like `v1.0.21-alpha+4b04517` should be dropped.
- **Consistency**: All new blueprint test files must follow this convention.
- **Documentation**: Each test file should include a comment explaining what CIP-57 feature or Aiken version behavior it validates.

## Rollout Plan

- [x] Define naming convention and sanitization rules.
- [x] Rename `AnyPlutusDataBlueprint.json` → `AnyPlutusDataBlueprint_aiken_v1_0_21_alpha.json`.
- [x] Update corresponding Java interfaces (`@Blueprint` annotation).
- [x] Enhance `AnyPlutusDataBlueprint` to include namespaced abstract types demonstrating the bug.
- [ ] Document convention in project README or developer guide.
- [ ] Apply convention to future blueprint test additions.
- [ ] Consider renaming `CIP113Token.json` → `CIP113Token_aiken_v1_1_17.json` for consistency (optional).

## Open Questions

- Should we rename existing functional test blueprints (like `CIP113Token`) or only apply this convention to new files?
  - **Proposal**: Apply retroactively for consistency, but prioritize new files.

- Should the convention extend to non-Aiken blueprints (PlutusTx, Helios)?
  - **Proposal**: Yes, using `<compiler>_v<version>` (e.g., `HelloWorld_plutustx_v1_2_0.json`).

- Should we validate filename-version consistency in tests?
  - **Proposal**: Defer to future ADR; manual convention is sufficient for now.
